This aims to both keep track of the following cardinalities:
	- Source Port
	- Source IP address
	- Destination IP address
	- Packet Length
	- SYN flags

Using a counter for SYN flags and a HyperLogLog sketch for cardinalities. 
Registers are used to store the necessary information.

Due to HLL's nature as a sketch, the data structure stored needs to be processed to obtain the estimate.
This is currently done out of the network. 
To this end, we implemented a some scripts to first obtain the registers' entries based on calc.p4's request/answer model, and assorted scripts to then process them into more human-readable formats.

Modifications of the latter parts are on-going.

1. For everything to work together, you'll need to make sure the following parameters fit together nicely:
* Check NUM_HLL_REGISTERS & INDEX_WIDTH in src/constants.p4. The first should be a power of 2, the latter should be equal to log_2 of the first, minus one.
* To read it from the scripts, make sure the action_blocks were generated by portDump_set.pl appropriately. Make sure its variable $N is set to NUM_HLL_REGISTERS and run it.  
* The dumpBlock_t header in src/headers.p4 needs to have enough 192 bits valueX block reserved to read six times NUM_HLL_REGISTER  worth of bits.

2. Start up the program and open up a client terminal with
```bash
make
mininet> xterm h1
```

3. From h1, the all-in-one script is extract_script.sh
```bash
./extract_script.sh <step>
```
This will send batchs of STEP packets, requesting the register entries after each batch is sent.
From h1, the returning packets will get stored in s1-eth1_in.pcap.
The script will then copy it to ./records, extract the payloads, process it into the estimate, and draw up a graph of them.


You can tweak how many batches are sent in the code, or do the operations by hand:

In ./py, use
```bash
test.py <N> [<dstPort>]
```
To send N packets for the switch to process

```bash
dump.py <portBlock> <feature code> 
```
to request a the entries of (port,feature) from the switch, with
   - 2314 <-> SrcIP
   - 2315 <-> DstIP
   - 2316 <-> SrcPort
   - 2317 <-> PktLen
 **<Port> must be <= NUM_N_FLOWS in src/constants.p4 !**

```bash
./decode.py <filename> <step> 
```
To change a cropped payload file of a given step into the corresponding human register entries as lists in regentries_<step>

and
```bash
./estimate.py <num_entries> <step>
```
To write the human readable estimate and plot a graph out of them.

START
Parse packets 
If instance_type==0 (Non recirculated packet) && SYN
	SYN_COUNTER++
exact match on hdr.tcp.dstPort,			
	write meta.portBlock
	//exact because we assume we know exactly which top K ports we're looking for
exact match on hdr.ethernet.ethertype
	write meta.feature
	// meta.feature in {IPsrc, IPdst, srcPort, PktLen}
exact match on meta.feature
	apply matching feature_hash 
	// we can't just pass an argument due to register references having to be compile constants

feature_hash()
	meta.hash			<- crc32_custom hash of (meta.feature)
	meta.index			<- hash[7:0]
	meta.remnant		<- hash[31:8]
	meta.address		<- index+N*meta.portBlock
	meta.current_zeroes <- feature_masterRegister(address) //This forces the last match

lpm match on meta.remnant
	write meta.these_zeroes
	//This is the most efficient way to count zeroes, only [remnant length] entries needed
exact match on meta.feature 
	apply feature_write_zeroes
	//Second call of the same table: need to duplicate it. Thankfully, it only has [num feature] entries, so it's lightweight

feature_write_zeroes
	push max(meta.current_zeroes, meta.these_zeroes) at feature_masterRegister(address)
	
exact match on hdr.ethernet.ethertype
	increment & recirculate
	OR
	drop packet



