#!/usr/bin/env python

import scipy as sp

# We have four+ registers of size REGISTERS_SIZE
# Each entry is a bitmap
# Their count is ~ bitwidth*ln(bitwidth/Z), where Z is the number of zeroes

# Right now we feed a given distribution with spam.py, get the registers, feed them to decode.py as a reg variable, and observe the difference. 
# It works, but should be automated. TODO!

reg=[ 1, 512, 49152, 8404994, 536870994, 21004294, 86003714, 194003968, 1141113730, 941623456, 1085346848, 1077348900, 30114532, 805356635, 1213412546, 8984920, 177893396, 1731753345, 324599899, 1427974618, 263231789, 1952150708, 1406993113, 904162376, 361088943, 1767818668, 1810312750, 1986247652, 1811748322, 156209115, 1066399234, 2074379515, 1455380462, 1953398555, 1672277743, 1726914269, 980414463, 2087384524, 530935678, 1790836447, 1469708218, 268368799, 1877851391, 1577049817, 780124159, 1071380452, 1879007226, 1037942109, 1576998839, 2137603071, 2147467117, 268308319, 2146936447, 2142896054, 1073725351, 1071618923, 2147213183, 1551826684, 1541922526, 1858075647, 2146385343, 2075638703, 2144862203, 536870891, 2146951143, 2097084399, 1593831423, 1858060286, 2134867963, 2145386479, 2147483631, 2126510079, 2147483487, 2113928703, 1876553151, 2147465215, 2113896319, 2147483135, 1073735675, 2147474367, 2130706431, 2147088379, 2147483263, 2113929215, 2147483647, 1879048191, 937426943, 2130640895, 2147483647, 2146959223, 2147479423, 2146435039, 1073741823, 2013130751, 2147483647, 2147418111, 2147483647, 2147483135, 2130575359, 2147483647, 1409286143, 2130706427, 2147418111, 2147483635, 2145386415, 2147482607, 2147467263, 2147483646, 2146959359, 2147221438, 2113929215, 2147483647, 2147483647, 2147483647, 2147483647, 2147483647, 2147481599, 2147483647, 2147483647, 2147483647, 2147483647, 2147483647, 2147483647, 2147418111, 2147467263, 2147483647, 2013265919, 2147483647, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

def count_zeroes(n):		# fun : int -> int. When fed N, returns Z=how many zeroes are in its binary form
	res=0
	bn=bin(n)[2:]
	for i in bn:
		if int(i)==0:
			res=res+1
	res=res+32-len(bn)
	return(res)

counts=[]
bins=[]
bitwidth=32					# Bitmaps' size parameter
for port in range(len(reg)):					# Every entry corresponds to a dstPort with its own bitmap. 
	bins.append(bin(reg[port])[2:])
	sum=0
	Z=count_zeroes(reg[port])
	if Z!=0:
		sum=sum+bitwidth*sp.log(float(bitwidth)/Z)	
		X=bitwidth-Z
	counts.append(sum)
	if reg[port]!=0:
		indice=port; collisions=port-X
		print('%03d' %port, \
			  "collisions="+'{0:< 2d}'.format(collisions)+ \
			  '  est='+'{0:>8.2f}'.format(counts[-1])+ \
			  '  dif='+'{0:>8.2f}'.format(port-counts[-1])+ \
			  '  rel='+'{0:>7.3f}'.format(100*(port-counts[-1])/port)+'%'+ \
			  '{0:32d}' .format(int(bins[-1])))
#		 '{0:> 12,.2f}'.format(-e)
